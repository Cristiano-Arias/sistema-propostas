#!/usr/bin/env python3
"""
Blueprint de Rotas de Autenticação - Sistema de Propostas
Implementa as rotas /api/auth/* que o frontend está chamando
VERSÃO CORRIGIDA - Aceita tanto 'login' quanto 'email'
"""

from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity, get_jwt
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import logging
from datetime import datetime
import re
import sqlite3
import traceback

# Importar classes do sistema existente
from auth import AuthService
# from models import Usuario, db  # Comentar

# Configurar blueprint
auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

# Configurar rate limiting
limiter = Limiter(
    app=current_app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# Configurar logging
logger = logging.getLogger(__name__)

# Instanciar serviço de autenticação
# auth_service = AuthService()  # Comentar por enquanto

def validate_email(email):
    """Valida formato de email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_password_strength(password):
    """Valida força da senha"""
    if len(password) < 8:
        return False, "Senha deve ter pelo menos 8 caracteres"
    
    if not re.search(r'[A-Z]', password):
        return False, "Senha deve conter pelo menos uma letra maiúscula"
    
    if not re.search(r'[a-z]', password):
        return False, "Senha deve conter pelo menos uma letra minúscula"
    
    if not re.search(r'\d', password):
        return False, "Senha deve conter pelo menos um número"
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "Senha deve conter pelo menos um caractere especial"
    
    return True, "Senha válida"

def validar_acesso_perfil(perfil_requerido):
    """Middleware para validar acesso por perfil"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Obter token da requisição
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({
                    'success': False,
                    'error': 'Token ausente',
                    'message': 'Token de autenticação necessário'
                }), 401
            
            token = auth_header.split(' ')[1]
            
            try:
                # Decodificar token
                payload = jwt.decode(token, app.config['JWT_SECRET_KEY'], algorithms=['HS256'])
                perfil_usuario = payload.get('perfil')
                
                # Validar perfil
                if perfil_usuario != perfil_requerido:
                    logger.warning(f"Acesso negado: usuário com perfil '{perfil_usuario}' tentou acessar área de '{perfil_requerido}'")
                    return jsonify({
                        'success': False,
                        'error': 'Acesso negado',
                        'message': f'Esta área é exclusiva para {perfil_requerido}s'
                    }), 403
                
                # Adicionar informações do usuário à requisição
                request.usuario_id = payload.get('usuario_id')
                request.perfil = perfil_usuario
                
                return f(*args, **kwargs)
                
            except jwt.ExpiredSignatureError:
                return jsonify({
                    'success': False,
                    'error': 'Token expirado',
                    'message': 'Faça login novamente'
                }), 401
            except jwt.InvalidTokenError:
                return jsonify({
                    'success': False,
                    'error': 'Token inválido',
                    'message': 'Token de acesso inválido'
                }), 401
                
        return decorated_function
    return decorator

@auth_bp.route('/login', methods=['POST'])
@limiter.limit("20 per minute")
def login():
    """
    Endpoint de login com validação de perfil
    POST /api/auth/login
    """
    try:
        # Validar dados de entrada
        data = request.get_json()
        if not data:
            return jsonify({
                'success': False,
                'error': 'Dados inválidos',
                'message': 'JSON não fornecido'
            }), 400
        
        # Aceitar tanto 'email' quanto 'login'
        email = data.get('email') or data.get('login')
        if email:
            email = email.strip().lower()
        senha = data.get('senha', '')
        
        # Validações básicas
        if not email or not senha:
            return jsonify({
                'success': False,
                'error': 'Dados obrigatórios',
                'message': 'Email e senha são obrigatórios'
            }), 400
        
        # IMPORTANTE: Validar formato de email
        if '@' not in email or '.' not in email:
            return jsonify({
                'success': False,
                'error': 'Email inválido',
                'message': 'Formato de email inválido'
            }), 400
        
        # Obter IP do cliente
        ip_origem = request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)
        
        # Buscar usuário no banco
        from backend_render_fix import get_db
        import bcrypt

        conn = get_db()
        cursor = conn.cursor()
        
        # Debug: listar todos os usuários (remover em produção)
        cursor.execute('SELECT email, perfil FROM usuarios')
        todos_usuarios = cursor.fetchall()
        logger.info(f"Usuários no banco: {[(u['email'], u['perfil']) for u in todos_usuarios]}")
        
        # Buscar usuário específico
        cursor.execute('SELECT * FROM usuarios WHERE email = ?', (email,))
        usuario = cursor.fetchone()

        if not usuario:
            conn.close()
            logger.warning(f"Usuário não encontrado: {email}")
            return jsonify({
                'success': False,
                'error': 'Credenciais inválidas',
                'message': 'Email ou senha incorretos'
            }), 401

        # Verificar senha
        hash_db = usuario['senha']
        if isinstance(hash_db, str):
            hash_db = hash_db.encode('utf-8')
        
        if not bcrypt.checkpw(senha.encode('utf-8'), hash_db):
            conn.close()
            logger.warning(f"Senha incorreta para: {email}")
            return jsonify({
                'success': False,
                'error': 'Credenciais inválidas', 
                'message': 'Email ou senha incorretos'
            }), 401

        # Gerar token
        from backend_render_fix import gerar_token
        token = gerar_token(usuario['id'], usuario['perfil'])

        conn.close()

        # Retornar resposta padronizada
        resultado = {
            'success': True,
            'message': 'Login realizado com sucesso',
            'token': token,
            'access_token': token,
            'refresh_token': None,
            'usuario': {
                'id': usuario['id'],
                'nome': usuario['nome'],
                'email': usuario['email'],
                'tipo': usuario['perfil'],  # Frontend espera 'tipo'
                'perfil': usuario['perfil']  # Manter ambos
            }
        }
        
        logger.info(f"Login bem-sucedido: {email} ({usuario['perfil']}) de {ip_origem}")
        return jsonify(resultado), 200
            
    except Exception as e:
        logger.error(f"Erro no login: {str(e)}")
        logger.error(f"Detalhes: {traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': 'Erro interno',
            'message': 'Erro interno do servidor'
        }), 500
@auth_bp.route('/logout', methods=['POST'])
@jwt_required()
def logout():
    """
    Endpoint de logout
    POST /api/auth/logout
    """
    try:
        # Obter JTI (JWT ID) do token atual
        jti = get_jwt()['jti']
        
        # Fazer logout usando o serviço
        resultado = auth_service.logout(jti)
        
        if resultado['success']:
            logger.info(f"Logout realizado com sucesso")
            return jsonify(resultado), 200
        else:
            return jsonify(resultado), 400
            
    except Exception as e:
        logger.error(f"Erro no logout: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Erro interno',
            'message': 'Erro interno do servidor'
        }), 500

@auth_bp.route('/me', methods=['GET'])
@jwt_required()
def get_current_user():
    """
    Endpoint para obter dados do usuário atual
    GET /api/auth/me
    """
    try:
        # Obter ID do usuário do token
        usuario_id = get_jwt_identity()
        
        # Buscar usuário no banco
        usuario = Usuario.query.get(usuario_id)
        if not usuario or not usuario.ativo:
            return jsonify({
                'success': False,
                'error': 'Usuário inválido',
                'message': 'Usuário não encontrado ou inativo'
            }), 401
        
        return jsonify({
            'success': True,
            'usuario': usuario.to_dict()
        }), 200
        
    except Exception as e:
        logger.error(f"Erro ao obter usuário atual: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Erro interno',
            'message': 'Erro interno do servidor'
        }), 500

@auth_bp.route('/register', methods=['POST'])
@limiter.limit("3 per minute")  # Rate limiting para cadastro
def register():
    """
    Endpoint de cadastro (apenas para administradores)
    POST /api/auth/register
    """
    try:
        # Validar dados de entrada
        data = request.get_json()
        if not data:
            return jsonify({
                'success': False,
                'error': 'Dados inválidos',
                'message': 'JSON não fornecido'
            }), 400
        
        nome = data.get('nome', '').strip()
        email = data.get('email', '').strip().lower()
        senha = data.get('senha', '')
        tipo = data.get('tipo', 'fornecedor').strip().lower()
        
        # Validações básicas
        if not all([nome, email, senha]):
            return jsonify({
                'success': False,
                'error': 'Dados obrigatórios',
                'message': 'Nome, email e senha são obrigatórios'
            }), 400
        
        if not validate_email(email):
            return jsonify({
                'success': False,
                'error': 'Email inválido',
                'message': 'Formato de email inválido'
            }), 400
        
        # Validar força da senha
        senha_valida, mensagem_senha = validate_password_strength(senha)
        if not senha_valida:
            return jsonify({
                'success': False,
                'error': 'Senha fraca',
                'message': mensagem_senha
            }), 400
        
        # Verificar se email já existe
        usuario_existente = Usuario.query.filter_by(email=email).first()
        if usuario_existente:
            return jsonify({
                'success': False,
                'error': 'Email já cadastrado',
                'message': 'Este email já está em uso'
            }), 409
        
        # Validar tipo de usuário
        tipos_validos = ['admin', 'comprador', 'requisitante', 'fornecedor', 'auditor']
        if tipo not in tipos_validos:
            return jsonify({
                'success': False,
                'error': 'Tipo inválido',
                'message': f'Tipo deve ser um de: {", ".join(tipos_validos)}'
            }), 400
        
        # Criar novo usuário
        novo_usuario = Usuario(
            nome=nome,
            email=email,
            tipo=tipo,
            nivel_acesso=1,  # Nível básico por padrão
            ativo=True
        )
        
        # Definir senha (será hasheada automaticamente)
        novo_usuario.set_senha(senha)
        
        # Salvar no banco
        db.session.add(novo_usuario)
        db.session.commit()
        
        logger.info(f"Novo usuário cadastrado: {email} (tipo: {tipo})")
        
        return jsonify({
            'success': True,
            'message': 'Usuário cadastrado com sucesso',
            'usuario': {
                'id': novo_usuario.id,
                'nome': novo_usuario.nome,
                'email': novo_usuario.email,
                'tipo': novo_usuario.tipo
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro no cadastro: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Erro interno',
            'message': 'Erro interno do servidor'
        }), 500

@auth_bp.route('/change-password', methods=['POST'])
@jwt_required()
@limiter.limit("3 per minute")
def change_password():
    """
    Endpoint para alterar senha
    POST /api/auth/change-password
    """
    try:
        # Obter usuário atual
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if not usuario or not usuario.ativo:
            return jsonify({
                'success': False,
                'error': 'Usuário inválido',
                'message': 'Usuário não encontrado ou inativo'
            }), 401
        
        # Validar dados de entrada
        data = request.get_json()
        if not data:
            return jsonify({
                'success': False,
                'error': 'Dados inválidos',
                'message': 'JSON não fornecido'
            }), 400
        
        senha_atual = data.get('senha_atual', '')
        senha_nova = data.get('senha_nova', '')
        
        if not senha_atual or not senha_nova:
            return jsonify({
                'success': False,
                'error': 'Dados obrigatórios',
                'message': 'Senha atual e nova senha são obrigatórias'
            }), 400
        
        # Verificar senha atual
        if not usuario.verificar_senha(senha_atual):
            return jsonify({
                'success': False,
                'error': 'Senha incorreta',
                'message': 'Senha atual incorreta'
            }), 401
        
        # Validar força da nova senha
        senha_valida, mensagem_senha = validate_password_strength(senha_nova)
        if not senha_valida:
            return jsonify({
                'success': False,
                'error': 'Senha fraca',
                'message': mensagem_senha
            }), 400
        
        # Alterar senha
        usuario.set_senha(senha_nova)
        db.session.commit()
        
        logger.info(f"Senha alterada para usuário: {usuario.email}")
        
        return jsonify({
            'success': True,
            'message': 'Senha alterada com sucesso'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro na alteração de senha: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Erro interno',
            'message': 'Erro interno do servidor'
        }), 500

# Handlers de erro para o blueprint
@auth_bp.errorhandler(429)
def ratelimit_handler(e):
    """Handler para rate limiting"""
    return jsonify({
        'success': False,
        'error': 'Muitas tentativas',
        'message': 'Muitas tentativas. Tente novamente mais tarde.'
    }), 429

@auth_bp.errorhandler(400)
def bad_request_handler(e):
    """Handler para requisições inválidas"""
    return jsonify({
        'success': False,
        'error': 'Requisição inválida',
        'message': 'Dados da requisição inválidos'
    }), 400

@auth_bp.errorhandler(401)
def unauthorized_handler(e):
    """Handler para não autorizado"""
    return jsonify({
        'success': False,
        'error': 'Não autorizado',
        'message': 'Acesso negado'
    }), 401

@auth_bp.errorhandler(500)
def internal_error_handler(e):
    """Handler para erros internos"""
    return jsonify({
        'success': False,
        'error': 'Erro interno',
        'message': 'Erro interno do servidor'
    }), 500
